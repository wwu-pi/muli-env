package applications.tcg;

import java.util.List;
import java.util.Arrays;
import de.wwu.muli.*;
import de.wwu.muli.solution.*;
import java.lang.Object;
import de.wwu.muli.tcg.*;
import java.lang.Math;

public class MainBellman {

    public static void main(String[] args) {
        Solution[] solutions = Muli.getAllSolutionsWithTestCases(BellmanFord::searchRegion, BellmanFord.class.getName() + ".runBellmanFord");
        for(Solution s : solutions){
            System.out.println("output: "+ s.value);
            TestCase<?> tc = s.testCase;
            Object[] inputs = tc.getInputs();
            for(Object o : inputs) {
                //Arrayref ref = (Arrayref) o;
                System.out.println("input: "+o.toString());
            }
        }
        TestCaseGenerator tcg = TestCaseGenerator.get(solutions);
        String test = tcg.generateTestClassStringRepresentation();
        System.out.println(test);
    }

}

class BellmanFord {
     static final int INFINITY = Integer.MAX_VALUE;

      static int[] runBellmanFord(int N, int D[], int src) {
        // Initialize distances.
        int[] dist = new int[N];
        //if(dist.length != N) throw Muli.fail();
        boolean[] infinite = new boolean[N];
        //if(infinite.length != N) throw Muli.fail();
        for (int i = 0; i < N; i++) { // V+1 branches
          dist[i] = INFINITY;
          infinite[i] = true;
        }
        dist[src] = 0;
        infinite[src] = false;

        // Keep relaxing edges until either:
        //  (1) No more edges need to be updated.
        //  (2) We have passed through the edges N times.
        int k;
        for (k = 0; k < N; k++) { // V+1 branches
          boolean relaxed = false;
          for (int i = 0; i < N; i++) { // V(V+1) branches
            for (int j = 0; j < N; j++) { // V^2(V+1) branches
              if (i == j) continue; // V^3 branches
              if (!infinite[i]) { // V^2(V-1) branches
                if (dist[j] > dist[i] + D[i * N + j]) { // V^2(V-1) branches
                  dist[j] = dist[i] + D[i * N + j];
                  infinite[j] = false;
                  relaxed = true;
                }
              }
            }
          }
          if (!relaxed) // V branches
          break;
        }

        // Check for negative-weight egdes.
        if (k == N) { // 1 branch
          // We relaxed during the N-th iteration, so there must be
          // a negative-weight cycle.
        }

        // Return the computed distances.
        return dist;
      }

    static int[] searchRegion() {
         final int V = (int) (1 + Math.random() * 5);//= Verifier.nondetInt();
         /*if(!(V > 0 && V < 2)){
            throw Muli.fail();
         }*/ // V*V < Integer.MAX_VALUE

         final int[] D = new int[V * V];
         //if(D.length != (V * V)) throw Muli.fail();

         for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                 if (i == j) continue;
                 int tmp = (int) (Math.random() * (V-1));
                 System.out.println("edge: "+tmp);
                 /*if(!(tmp >= 0 && tmp < V)){
                    throw Muli.fail();
                 }*/
                 D[i * V + j] = tmp;
               }
             }

         int[] dist = runBellmanFord(V, D, 0);
         return dist;
    }
}


public class Verifier{
    public static int nondetInt() {
        int i free;
        return i;
    }

    public static void assume(boolean condition){
        if(!condition){
            throw Muli.fail();
        }
    }
}